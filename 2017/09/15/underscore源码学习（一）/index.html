<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="A contented mind is a perpetual feast."><title>underscore源码学习（一） | WaterBlog</title><link rel="stylesheet" type="text/css" href="/css/style.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">underscore源码学习（一）</h1><a id="logo" href="/.">WaterBlog</a><p class="description">WaterGayGay的博客</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/collection/"><i class="fa fa-bookmark"> 收藏</i></a><a href="/history/"><i class="fa fa-book"> 历史</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">underscore源码学习（一）</h1><div class="post-meta">Sep 15, 2017</div><div class="post-content"><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近在社区浏览文章的时候，看到了一位大四学长在寻求前端工作中的面经，看完不得不佩服，掌握知识点真是全面，无论是前端后台还是其他，都有涉猎。</p>
<p>在他写的文章中，有这么一句话，大概意思是，<code>没有看过一个库或者框架的源码还敢出来混</code>。然后自己心虚了一下，一直以来，都只是学习使用框架或库，或者在过程中有学习框架的思想，但并不深入。例如，在学习<code>Vue.js</code>中，我曾经去探索过Vue中的双向绑定是如何实现的，通过什么模式，什么API，作者的思想是什么，也曾经实现过简单版的双向绑定。<br><a id="more"></a><br>但是感觉自己在这方面并没有什么提高，尤其在原生JavaScript的学习中，一些不常用的API经常忘，思维也不够好。所以有了学习优秀的库的源码的想法，一方面能够学习作者的思想，提高自己的分析能力，另一方面我觉得如果能好好分析一个库的源码，对自己的提升也是有的。</p>
<p>所以，刚开始，我从源码比较短的<code>underscore.js</code>(包含注释只有1.5k行)开始学习起。</p>
<h3 id="什么是underscore"><a href="#什么是underscore" class="headerlink" title="什么是underscore"></a>什么是underscore</h3><p>Underscore一个JavaScript实用库，提供了一整套函数式编程的实用功能，但是没有扩展任何JavaScript内置对象。它是这个问题的答案：“如果我在一个空白的HTML页面前坐下， 并希望立即开始工作， 我需要什么？“…它弥补了部分jQuery没有实现的功能,同时又是Backbone.js必不可少的部分。——摘自Underscore中文文档</p>
<p>我的学习之路是基于Underscore1.8.3版本开始的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Current version.</span></div><div class="line"> _.VERSION = <span class="string">'1.8.3'</span>;</div></pre></td></tr></table></figure>
<h3 id="作用域包裹"><a href="#作用域包裹" class="headerlink" title="作用域包裹"></a>作用域包裹</h3><p>与其他第三方库一样，underscore最外层是一个立即执行函数(IIFE)，来包裹自己的业务逻辑。一般使用IIFE有如下好处，可以创建一个独立的沙箱似的作用域，避免全局污染，还可以防止其他代码对该函数内部造成影响。(但凡在立即执行函数中声明的函数、变量等，除非是自己想暴露，否则绝无可能在外部获得)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"></div><div class="line">	<span class="comment">// ...执行逻辑</span></div><div class="line">	</div><div class="line">&#125;.call(<span class="keyword">this</span>))</div></pre></td></tr></table></figure>
<blockquote>
<p>学习的点，当我们要写自己的库或者封装某个功能函数时，可以给自己的库或函数在最外层包裹一个立即执行函数，这样既不会受外部影响，也不会给外部添麻烦。</p>
</blockquote>
<h3 id="对象"><a href="#对象" class="headerlink" title="_对象"></a>_对象</h3><p>underscore有下划线的意思，所以underscore通过一个下划线变量<code>_</code>来标识自身，值得注意的是，<code>_</code>是一个函数对象或者说是一个构造函数，并且支持无new调用的构造的函数，所有API都会挂载在这个对象上，如<code>_.each,_.map</code>等<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> _ = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">	<span class="keyword">if</span>(obj <span class="keyword">instanceof</span> _) <span class="keyword">return</span> obj;</div><div class="line">	<span class="keyword">if</span>(!(<span class="keyword">this</span> <span class="keyword">instanceof</span> _)) <span class="keyword">return</span> <span class="keyword">new</span> _(obj) <span class="comment">//实例化</span></div><div class="line">	<span class="keyword">this</span>._wrapped = obj</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="全局命名空间"><a href="#全局命名空间" class="headerlink" title="全局命名空间"></a>全局命名空间</h3><p>underscore使用<code>root</code>变量保存了全局的<code>this</code>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> root = <span class="keyword">this</span>;</div></pre></td></tr></table></figure></p>
<p>为了防止其他库对<code>_</code>的冲突或影响，underscore做了如下处理，<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> previousUnderscore = root._</div><div class="line">_.noConflict = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	root._ = perviousUnderscore;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="执行环境判断"><a href="#执行环境判断" class="headerlink" title="执行环境判断"></a>执行环境判断</h3><p>underscore 既能够服务于浏览器，又能够服务于诸如 nodejs 所搭建的服务端。<br>一般，在客户端（浏览器）环境中，<code>_</code>即为<code>window._=_</code>，暴露在全局中。若在node环境中，<code>_</code>将被作为模块导出，并且向后兼容老的API，即require。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> exports !== <span class="string">'undefined'</span>) &#123;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">module</span> !== <span class="string">'undefined'</span> &amp;&amp; <span class="built_in">module</span>.exports) &#123;</div><div class="line">    exports = <span class="built_in">module</span>.exports = _;  </div><div class="line">  &#125;</div><div class="line">  exports._ = _ ;</div><div class="line">&#125; esle &#123;</div><div class="line">  root._ = _;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="缓存局部变量及快速引用"><a href="#缓存局部变量及快速引用" class="headerlink" title="缓存局部变量及快速引用"></a>缓存局部变量及快速引用</h3><p>underscore本身用到了不少ES5的原生方法，在浏览器支持的条件下，underscore率先使用原生的ES5方法。如下代码所示，underscore通过局部变量来保存一些常用到的方法或者属性。<br>这样做有几个好处：</p>
<ul>
<li>便于压缩代码</li>
<li>提高代码性能，减少在原型链中的查找次数</li>
<li>同时也可减少代码量，避免在使用时冗长的书写<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> ArrayProto = <span class="built_in">Array</span>.prototype, ObjProto = <span class="built_in">Object</span>.prototype, FuncProto = <span class="built_in">Function</span>.prototype;</div><div class="line"><span class="keyword">var</span></div><div class="line">  push             = ArrayProto.push,</div><div class="line">  slice            = ArrayProto.slice,</div><div class="line">  toString         = ObjProto.toString,</div><div class="line">  hasOwnProperty   = ObjProto.hasOwnProperty;</div><div class="line"><span class="keyword">var</span></div><div class="line">  nativeIsArray      = <span class="built_in">Array</span>.isArray,</div><div class="line">  nativeKeys         = <span class="built_in">Object</span>.keys,</div><div class="line">  nativeBind         = FuncProto.bind,</div><div class="line">  nativeCreate       = <span class="built_in">Object</span>.create;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="undefined处理"><a href="#undefined处理" class="headerlink" title="undefined处理"></a>undefined处理</h3><p>在underscore中，有很多函数都会有一个<code>context</code>函数，也就是当前函数的执行上下文，underscore对其进行了处理，如果没有传入<code>context</code>即<code>context</code>为<code>undefined</code>，则返回原函数。<br>这里判断值为<code>undefined</code>用的是<code>void 0</code>，如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (context === <span class="keyword">void</span> <span class="number">0</span>) <span class="keyword">return</span> func</div></pre></td></tr></table></figure></p>
<p>作为一只涉猎尚浅的小白，查阅<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/void" target="_blank" rel="external">资料</a>之后终于知道这里作者为什么要用<code>void 0</code>来做判断了。</p>
<p>详情可点链接了解，这样做更加安全可靠。<br>在还没看到这个代码时， 如果我要判断一个值是不是<code>undefined</code>，我会这样写<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (context === <span class="literal">undefined</span>) &#123;&#125;</div></pre></td></tr></table></figure></p>
<p>但是，在发现作者的<code>void 0</code>之后，才发现这样写并不可靠，在JavaScript中，我们可以这样写：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">args =&gt; &#123;</div><div class="line">  <span class="keyword">let</span> <span class="literal">undefined</span> = <span class="number">1</span></div><div class="line">  <span class="built_in">console</span>.log(<span class="literal">undefined</span>) <span class="comment">// =&gt; 1</span></div><div class="line">  <span class="keyword">if</span> (args === <span class="literal">undefined</span>) &#123;</div><div class="line">    <span class="comment">//...</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果这样写，<code>undefined</code>就被轻易地修改为了<code>1</code>，所以对于我们之后定义的<code>undefined</code>的理解有歧义。所以，在JavaScript中，把<code>undefined</code>直接解释为“未定义”是有风险的，因为它可能被修改。</p>
<blockquote>
<p>学习：以后判断<code>undefined</code>直接使用<code>void 0</code>, 看起来也优雅一点（滑稽脸）。</p>
</blockquote>
<h3 id="处理类数组"><a href="#处理类数组" class="headerlink" title="处理类数组"></a>处理类数组</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// getLength 函数</span></div><div class="line"><span class="comment">// 该函数传入一个参数，返回参数的 length 属性值</span></div><div class="line"><span class="comment">// 用来获取 array 以及 arrayLike 元素的 length 属性值</span></div><div class="line"><span class="keyword">var</span> getLength = property(<span class="string">'length'</span>);</div><div class="line"></div><div class="line"><span class="comment">// 判断是否是 ArrayLike Object</span></div><div class="line"><span class="comment">// 类数组，即拥有 length 属性并且 length 属性值为 Number 类型的元素</span></div><div class="line"><span class="comment">// 包括数组、arguments、HTML Collection 以及 NodeList 等等</span></div><div class="line"><span class="comment">// 包括类似 &#123;length: 10&#125; 这样的对象</span></div><div class="line"><span class="comment">// 包括字符串、函数等</span></div><div class="line"><span class="keyword">var</span> isArrayLike = <span class="function"><span class="keyword">function</span>(<span class="params">collection</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> length = getLength(collection);</div><div class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> length == <span class="string">'number'</span> &amp;&amp; length &gt;= <span class="number">0</span> &amp;&amp; length &lt;= MAX_ARRAY_INDEX;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="对象创建的特殊处理"><a href="#对象创建的特殊处理" class="headerlink" title="对象创建的特殊处理"></a>对象创建的特殊处理</h3><p>为了处理<code>Object.create</code>的跨浏览器的兼容性，underscore进行了特殊的处理。我们知道，原型是无法直接实例化的，因此我们先创建一个空对象，然后将其原型指向这个我们想要实例化的原型，最后返回该对象其一个实例。其代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Ctor = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;  <span class="comment">// 用于代理原型转换的空函数</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> baseCreate = <span class="function"><span class="keyword">function</span>(<span class="params">prototype</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (!(_.isObject(prototype))) <span class="keyword">return</span> &#123;&#125;; <span class="comment">// 如果参数不是对象，直接返回空对象</span></div><div class="line">  <span class="keyword">if</span> (nativeCreate) <span class="keyword">return</span> nativeCreate(prototype); <span class="comment">// 如果原生的对象创建可以使用，返回该方法根据原型创建的对象</span></div><div class="line">    </div><div class="line">  <span class="comment">// 处理没有原生对象创建的情况</span></div><div class="line">  Ctor.prototype = prototype;  <span class="comment">// 将空函数的原型指向要使用的原型</span></div><div class="line">  <span class="keyword">var</span> result = <span class="keyword">new</span> Ctor();  <span class="comment">// 创建一个实例</span></div><div class="line">  Ctor.prototype = <span class="literal">null</span>;  <span class="comment">// 恢复Ctor的原型供下次使用</span></div><div class="line">  <span class="keyword">return</span> result;  <span class="comment">// 返回该实例</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="underscore中的迭代-iteratee"><a href="#underscore中的迭代-iteratee" class="headerlink" title="underscore中的迭代(iteratee)"></a>underscore中的迭代(iteratee)</h3><p>在函数式编程中，使用更多的是迭代，而不是循环。<br>迭代：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> res = _.map([<span class="number">1</span>,<span class="number">2</span>], <span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> item * <span class="number">2</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>循环：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>]</div><div class="line"><span class="keyword">var</span> res = []</div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</div><div class="line">  res.push(arr[i] * <span class="number">2</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在underscore中迭代使用非常巧妙，源码也写的非常好，通过传入的数据类型不同而选择不同的迭代函数。<br>首先，在underscore中<code>_.map</code>的实现如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">_.map = _.collect = <span class="function"><span class="keyword">function</span>(<span class="params">obj, iteratee, context</span>) </span>&#123;</div><div class="line">  iteratee = cb(iteratee, context);</div><div class="line">  <span class="keyword">var</span> keys = !isArrayLike(obj) &amp;&amp; _.keys(obj),</div><div class="line">      length = (keys || obj).length,</div><div class="line">      results = <span class="built_in">Array</span>(length);</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> index = <span class="number">0</span>; index &lt; length; index++) &#123;</div><div class="line">    <span class="keyword">var</span> currentKey = keys ? keys[index] : index;</div><div class="line">    results[index] = iteratee(obj[currentKey], currentKey, obj) <span class="comment">//(value, index, obj)</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> results;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到，在<code>_.map</code>函数中的第二个参数<code>iteratee</code>，这个参数的格式可以是函数，对象，字符串。underscore会将其处理成一个函数，这将由回调函数<code>cb</code>来完成，我们来看一下<code>cb</code>的实现：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> cb = <span class="function"><span class="keyword">function</span>(<span class="params">value, context, argCount</span>) </span>&#123;</div><div class="line"> <span class="comment">// 是否用默认的迭代器 如果没有传入value 则返回当前迭代元素自身</span></div><div class="line"> <span class="keyword">if</span> (value == <span class="literal">null</span>) <span class="keyword">return</span> _.identity;</div><div class="line"> <span class="comment">// 如果value是一个回调函数, 则需要优化回调 优化函数为optimizeCb</span></div><div class="line"> <span class="keyword">if</span> (_.isFunction(value)) <span class="keyword">return</span> optimizeCb(value, context, argCount);</div><div class="line"> <span class="comment">// 如果value是个对象, 则返回一个matcher进行对象匹配</span></div><div class="line"> <span class="keyword">if</span> (_.isObject(value)) <span class="keyword">return</span> _.matcher(value)</div><div class="line"> <span class="comment">// 否则, 如果value只是一个字面量, 则把value看做是属性名称, 返回一个对应的属性获得函数</span></div><div class="line"> <span class="keyword">return</span> _.property(value);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>前面两个比较容易理解，看看当传入的数据格式为对象的情况，如果 value 传入的是一个对象，那么返回iteratee（_.matcher）的目的是想要知道当前被迭代元素是否匹配给定的这个对象：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> results = _.map([&#123;name:<span class="string">'water'</span>&#125;,&#123;name: <span class="string">'lzb'</span>,age:<span class="number">13</span>&#125;], &#123;name: <span class="string">'lzb'</span>&#125;);</div><div class="line"><span class="comment">// =&gt; results: [false,true]</span></div></pre></td></tr></table></figure></p>
<p>如果传入的是字面量，如数字，字符串等， 他会返回对应的key值，如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> results = _.map([&#123;name:<span class="string">'water'</span>&#125;,&#123;name:<span class="string">'lzb'</span>&#125;],<span class="string">'name'</span>);</div><div class="line"><span class="comment">// =&gt; results: ['water', 'lzb'];</span></div></pre></td></tr></table></figure></p>
<h3 id="回调处理"><a href="#回调处理" class="headerlink" title="回调处理"></a>回调处理</h3><p>在上面的<code>cb</code>函数中，我们可以看到，当传入的数据格式是函数，则需要通过<code>optimizeCb</code>函数进行统一处理，返回对应的回调函数，下面是underscore中<code>optimizeCb</code>函数的实现：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 回调处理</span></div><div class="line"><span class="comment">// underscore 内部方法</span></div><div class="line"><span class="comment">// 根据 this 指向（context 参数）</span></div><div class="line"><span class="comment">// 以及 argCount 参数</span></div><div class="line"><span class="comment">// 二次操作返回一些回调、迭代方法</span></div><div class="line"><span class="keyword">var</span> optimizeCb = <span class="function"><span class="keyword">function</span>(<span class="params">func, context, argCount</span>) </span>&#123;</div><div class="line">  <span class="comment">// // void 0 会返回纯正的undefined,这样做避免undefined已经被污染带来的判定失效</span></div><div class="line">  <span class="keyword">if</span> (context === <span class="keyword">void</span> <span class="number">0</span>) <span class="keyword">return</span> func;</div><div class="line">  <span class="keyword">switch</span> (argCount == <span class="literal">null</span> ? <span class="number">3</span> : argCount) &#123;</div><div class="line">    <span class="comment">// 回调参数为1时, 即迭代过程中,我们只需要值</span></div><div class="line">    <span class="comment">// _.times</span></div><div class="line">    <span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> func.call(context, value);</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">case</span> <span class="number">2</span>: <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">value, other</span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> func.call(context, value, other);</div><div class="line">    &#125;;</div><div class="line">    <span class="comment">// 3个参数(值,索引,被迭代集合对象)</span></div><div class="line">    <span class="comment">// _.each、_.map  (value, key, obj)</span></div><div class="line">    <span class="keyword">case</span> <span class="number">3</span>: <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">value, index, collection</span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> func.call(context, value, index, collection);</div><div class="line">    &#125;;</div><div class="line">    <span class="comment">// 4个参数(累加器(比如reducer需要的), 值, 索引, 被迭代集合对象)</span></div><div class="line">    <span class="comment">// _.reduce、_.reduceRight</span></div><div class="line">    <span class="keyword">case</span> <span class="number">4</span>: <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">accumulator, value, index, collection</span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> func.call(context, accumulator, value, index, collection);</div><div class="line">    &#125;;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 如果都不符合上述的任一条件，直接使用apply调用相关函数</span></div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> func.apply(context, <span class="built_in">arguments</span>);</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>optimizeCb</code> 的总体思路就是：传入待优化的回调函数 <code>func</code>，以及迭代回调需要的参数个数<code>argCount</code>，根据参数个数分情况进行优化。</p>
<p>在underscore的<code>_.times</code>函数视线中，<code>_times</code>的作用执行一个传入<code>iteratee</code>函数<code>n</code>次，并返回由每次执行结果组成的数组。它的迭代过程<code>iteratee</code>只需要1个参数(当前迭代的索引)<br><code>_.times</code>函数在underscore中的实现：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">_.times = <span class="function"><span class="keyword">function</span>(<span class="params">n, iteratee, context</span>) </span>&#123;</div><div class="line">  vat accum = <span class="built_in">Array</span>(<span class="built_in">Math</span>.max(<span class="number">0</span>, n));</div><div class="line">  iteratee = optimizeCb(iteratee, context, <span class="number">1</span>);</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; n; i++) accum[i] = iteratee(i);</div><div class="line">  <span class="keyword">return</span> accum;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>_.times</code>的使用<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getIndex</span>(<span class="params">index</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> index;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> results = _.times(<span class="number">3</span>, getIndex); <span class="comment">// =&gt; [0,1,2]</span></div></pre></td></tr></table></figure></p>
<p><code>optimizeCb</code>函数中当<code>argCount</code>的个数为2的情况并不常见，在<code>_.each,_.map</code>等函数中，<code>argCount</code>的值为3<code>(value, key, obj)</code>，当<code>argCount</code>需要四个参数时，这四个参数的格式为：</p>
<ul>
<li><code>accumulator</code>：累加器</li>
<li><code>value</code>：迭代元素</li>
<li><code>index</code>：迭代索引</li>
<li><code>collection</code>：当前迭代集合</li>
</ul>
<p>underscore中<code>reduce</code>的实现如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * reduce函数的工厂函数, 用于生成一个reducer, 通过参数决定reduce的方向</div><div class="line"> * @param dir 方向 left or right</div><div class="line"> * @returns &#123;function&#125;</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createReduce</span>(<span class="params">dir</span>) </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">iterator</span>(<span class="params">obj, iteratee, memo, keys, index, length</span>) </span>&#123;</div><div class="line">    <span class="keyword">for</span>(; index &gt;= <span class="number">0</span> &amp;&amp; index &lt; length; index += dir) &#123;</div><div class="line">      <span class="keyword">var</span> currentKey = keys ? keys[index] : index;</div><div class="line">      <span class="comment">// memo 用来记录最新的 reduce 结果</span></div><div class="line">      <span class="comment">// 执行 reduce 回调, 刷新当前值</span></div><div class="line">      memo = iteratee(memo, obj[currentKey], currentKey, obj);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> memo;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">obj, iteratee, memo, context</span>) </span>&#123;</div><div class="line">    <span class="comment">// 优化回调</span></div><div class="line">    iteratee = optimizeCb(iteratee, context, <span class="number">4</span>);</div><div class="line">    <span class="keyword">var</span> keys = !isArrayLike(obj) &amp;&amp; _.keys(obj),</div><div class="line">        length = (keys || obj).length,</div><div class="line">        index = dir &gt; <span class="number">0</span> ? <span class="number">0</span> : length - <span class="number">1</span>;</div><div class="line">    <span class="keyword">if</span> (<span class="built_in">arguments</span>.length &lt; <span class="number">3</span>) &#123;</div><div class="line">      <span class="comment">// 如果没有传入memo初始值 则从左第一个为初始值 从右则最后一个为初始值</span></div><div class="line">      memo = obj[keys ? keys[index] : index];</div><div class="line">      index += dir;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// return func</span></div><div class="line">    <span class="keyword">return</span> iterator(obj, iteratee, memo, keys, index, length);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>例如在<code>_.reduce、_.reduceRight</code>中，<code>argCount</code>的值为4。看看underscore中<code>_.reduce</code>的使用例子<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> sum = _.reduce([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], <span class="function"><span class="keyword">function</span>(<span class="params">accumulator, value, index, collection</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> accumulator + value;</div><div class="line">&#125;, <span class="number">0</span>) <span class="comment">// =&gt; 10</span></div></pre></td></tr></table></figure></p>
</div><div class="tags"><a href="/tags/JavaScript/">JavaScript</a></div><div class="post-nav"><a href="/2017/09/17/underscore源码学习（二）/" class="pre">underscore源码学习（二）</a><a href="/2017/08/22/JavaScript-Sorting-Algorithm/" class="next">JavaScript Sorting Algorithm</a></div><div id="container"></div><link rel="stylesheet" href="/css/default.css?v=1.0.0"><script src="/js/gitment.browser.js?v=1.0.0"></script><script>var gitment = new Gitment({
  owner: 'k-water',
  repo: 'k-water.github.io',
  oauth: {
    client_id: 'b80d9a577bec58f5cd74',
    client_secret: 'bb14317e485db9a408465da9eac80af12e340ad9',
  },
})
gitment.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://waterlin.cn"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/more/"><!--more--></a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Algorithm/">Algorithm</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/BackEnd/">BackEnd</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/FontEnd/">FontEnd</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Server/">Server</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Tool/">Tool</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/jQuery/" style="font-size: 15px;">jQuery</a> <a href="/tags/HTML5/" style="font-size: 15px;">HTML5</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/blog/" style="font-size: 15px;">blog</a> <a href="/tags/Algorithm/" style="font-size: 15px;">Algorithm</a> <a href="/tags/Data-struct/" style="font-size: 15px;">Data struct</a> <a href="/tags/JavaScript/" style="font-size: 15px;">JavaScript</a> <a href="/tags/Sass/" style="font-size: 15px;">Sass</a> <a href="/tags/Browser/" style="font-size: 15px;">Browser</a> <a href="/tags/HTTP/" style="font-size: 15px;">HTTP</a> <a href="/tags/BFC/" style="font-size: 15px;">BFC</a> <a href="/tags/node/" style="font-size: 15px;">node</a> <a href="/tags/CSS/" style="font-size: 15px;">CSS</a> <a href="/tags/CSS3/" style="font-size: 15px;">CSS3</a> <a href="/tags/ES6/" style="font-size: 15px;">ES6</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/Blog/" style="font-size: 15px;">Blog</a> <a href="/tags/Vue/" style="font-size: 15px;">Vue</a> <a href="/tags/服务器/" style="font-size: 15px;">服务器</a> <a href="/tags/MongoDB/" style="font-size: 15px;">MongoDB</a> <a href="/tags/汇编/" style="font-size: 15px;">汇编</a> <a href="/tags/转载/" style="font-size: 15px;">转载</a> <a href="/tags/RegExp/" style="font-size: 15px;">RegExp</a> <a href="/tags/IFE/" style="font-size: 15px;">IFE</a> <a href="/tags/Electron/" style="font-size: 15px;">Electron</a> <a href="/tags/VSCode/" style="font-size: 15px;">VSCode</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/09/29/underscore源码学习（七）/">underscore源码学习（七）</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/27/underscore源码学习（六）/">underscore源码学习（六）</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/26/underscore源码学习（五）/">underscore源码学习（五）</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/22/underscore源码学习（四）/">underscore源码学习（四）</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/19/underscore源码学习（三）/">underscore源码学习（三）</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/17/underscore源码学习（二）/">underscore源码学习（二）</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/15/underscore源码学习（一）/">underscore源码学习（一）</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/22/JavaScript-Sorting-Algorithm/">JavaScript Sorting Algorithm</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/18/在Vue中使用第三方库/">在Vue中使用第三方库</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/13/基于vue-electron的项目梳理总结/">基于vue-electron的项目梳理总结</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://blog.lxstart.net/" title="x-cold" target="_blank">x-cold</a><ul></ul><a href="http://www.cnblogs.com/liuweimingcprogram" title="SCAU_L" target="_blank">SCAU_L</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2016-2017 <a href="/." rel="nofollow">WaterBlog.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.css"><script type="text/javascript" color="0,0,0" opacity="0.5" zIndex="-2" count="50" src="//cdn.bootcss.com/canvas-nest.js/1.0.1/canvas-nest.min.js"></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script><script type="text/javascript" src="/js/background-canvas.js?v=1.0.0"></script></div></body></html>